{"type":"text","lines":["// Jot - JSON Optimized for Tokens","const RESERVED_WORDS = new Set([\"true\", \"false\", \"null\"]);","const UNSAFE_CHARS = [\":\", \",\", \"{\", \"}\", \"[\", \"]\", '\"', \";\", \"\\\\\"];","","function needsQuotes(str, unsafeChars) {","  if (str === \"\" || str.trim() !== str) return true;","  if (RESERVED_WORDS.has(str)) return true;","  if (!isNaN(Number(str))) return true;","  if (unsafeChars.some((c) => str.includes(c))) return true;","  if ([...str].some((c) => c.charCodeAt(0) < 32)) return true;","  return false;","}","","const quoteString = (s) => needsQuotes(s, UNSAFE_CHARS) ? JSON.stringify(s) : s;","const quoteKey = (s) => needsQuotes(s, [...UNSAFE_CHARS, \".\"]) ? JSON.stringify(s) : s;","const needsKeyQuoting = (s) => needsQuotes(s, [...UNSAFE_CHARS, \".\"]);","","function getObjectKeys(obj) { return Object.keys(obj); }","","function getFoldPath(value) {","  const path = [];","  let current = value;","  while (current !== null && typeof current === \"object\" && !Array.isArray(current)) {","    const keys = getObjectKeys(current);","    if (keys.length !== 1) break;","    const key = keys[0];","    if (key.includes(\".\")) break;","    path.push(key);","    current = current[key];","  }","  if (path.length < 1) return null;","  return { path, leaf: current };","}","","function isAllObjects(arr) {","  return arr.length >= 2 && arr.every((item) => item !== null && typeof item === \"object\" && !Array.isArray(item));","}","","function groupBySchema(arr) {","  const groups = [];","  for (const obj of arr) {","    const keys = getObjectKeys(obj);","    const keyStr = keys.join(\",\");","    if (groups.length > 0) {","      const lastGroup = groups[groups.length - 1];","      if (lastGroup.keys.join(\",\") === keyStr) {","        lastGroup.objects.push(obj);","        continue;","      }","    }","    groups.push({ keys, objects: [obj] });","  }","  return groups;","}","","function hasSchemaReuse(arr) {","  const groups = groupBySchema(arr);","  return groups.some((g) => g.objects.length >= 2);","}","","let currentOptions = { pretty: false, indent: \"  \" };","let depth = 0;","","function ind() {","  return currentOptions.pretty ? currentOptions.indent.repeat(depth) : \"\";","}","","function stringifyValue(value, atLineStart = false) {","  if (value === null) return \"null\";","  if (value === true) return \"true\";","  if (value === false) return \"false\";","  if (typeof value === \"number\") return String(value);","  if (typeof value === \"string\") return quoteString(value);","  if (Array.isArray(value)) return stringifyArray(value);","  if (typeof value === \"object\") return stringifyObject(value, atLineStart);","  return String(value);","}","","function hasComplexItems(arr) {","  return arr.some((item) => item !== null && typeof item === \"object\");","}","","function stringifyArray(arr) {","  if (isAllObjects(arr) && hasSchemaReuse(arr)) return stringifyTable(arr);","  if (arr.length === 1) return `[${stringifyValue(arr[0])}]`;","  if (currentOptions.pretty && arr.length > 0 && hasComplexItems(arr)) {","    depth++;","    const items = arr.map((item) => `${ind()}${stringifyValue(item, true)}`);","    depth--;","    return `[\\n${items.join(\",\\n\")}\\n${ind()}]`;","  }","  const sep = currentOptions.pretty ? \", \" : \",\";","  const items = arr.map(stringifyValue).join(sep);","  return currentOptions.pretty ? `[ ${items} ]` : `[${items}]`;","}","","function stringifyTable(arr) {","  const groups = groupBySchema(arr);","  const sep = currentOptions.pretty ? \", \" : \",\";","  if (currentOptions.pretty) {","    depth++;","    const schemaInd = ind();","    depth++;","    const dataInd = ind();","    const rows = [];","    for (const group of groups) {","      rows.push(schemaInd + `:${group.keys.map((k) => quoteKey(k)).join(sep)}`);","      for (const obj of group.objects) {","        rows.push(dataInd + group.keys.map((k) => stringifyValue(obj[k])).join(sep));","      }","    }","    depth -= 2;","    return `{{\\n${rows.join(\"\\n\")}\\n${ind()}}}`;","  }","  const parts = [];","  for (const group of groups) {","    parts.push(`:${group.keys.map((k) => quoteKey(k)).join(sep)}`);","    for (const obj of group.objects) {","      parts.push(group.keys.map((k) => stringifyValue(obj[k])).join(sep));","    }","  }","  return `{{${parts.join(\";\")}}}`;","}","","function stringifyObject(obj, atLineStart = false) {","  const keys = getObjectKeys(obj);","  const stringifyPair = (k, forPretty) => {","    const val = obj[k];","    const quotedKey = quoteKey(k);","    if (!needsKeyQuoting(k) && val !== null && typeof val === \"object\" && !Array.isArray(val)) {","      const fold = getFoldPath(val);","      if (fold) {","        const foldedKey = `${k}.${fold.path.join(\".\")}`;","        return forPretty ? `${foldedKey}: ${stringifyValue(fold.leaf, false)}` : `${foldedKey}:${stringifyValue(fold.leaf)}`;","      }","    }","    return forPretty ? `${quotedKey}: ${stringifyValue(val, false)}` : `${quotedKey}:${stringifyValue(val)}`;","  };","  if (currentOptions.pretty && keys.length > 1) {","    depth++;","    const rawPairs = keys.map((k) => stringifyPair(k, true));","    const lastIsMultiLine = rawPairs[rawPairs.length - 1].endsWith(\"}\") || rawPairs[rawPairs.length - 1].endsWith(\"]\");","    const useCompact = atLineStart && !lastIsMultiLine;","    const pairs = [];","    for (let i = 0; i < keys.length; i++) {","      pairs.push(i === 0 && useCompact ? rawPairs[i] : `${ind()}${rawPairs[i]}`);","    }","    depth--;","    return useCompact ? `{ ${pairs.join(\",\\n\")} }` : `{\\n${pairs.join(\",\\n\")}\\n${ind()}}`;","  }","  if (currentOptions.pretty && keys.length === 1) return `{ ${stringifyPair(keys[0], true)} }`;","  const pairs = keys.map((k) => stringifyPair(k, false));","  return `{${pairs.join(\",\")}}`;","}","","function stringify(data, options = {}) {","  currentOptions = { pretty: false, indent: \"  \", ...options };","  depth = 0;","  return stringifyValue(data);","}","","// Parser","class JotParser {","  constructor(input) {","    this.input = input;","    this.pos = 0;","  }","  ","  parse() {","    this.skipWhitespace();","    const result = this.parseValue(\"\");","    this.skipWhitespace();","    if (this.pos < this.input.length) {","      throw new Error(`Unexpected character at position ${this.pos}: '${this.input[this.pos]}'`);","    }","    return result;","  }","  ","  skipWhitespace() {","    while (this.pos < this.input.length && /\\s/.test(this.input[this.pos])) this.pos++;","  }","  ","  peek() { return this.input[this.pos] || \"\"; }","  ","  parseValue(terminators = \"\") {","    this.skipWhitespace();","    const ch = this.peek();","    if (ch === \"{\") {","      if (this.input[this.pos + 1] === \"{\") return this.parseTable();","      return this.parseObject();","    }","    if (ch === \"[\") return this.parseArray();","    if (ch === '\"') return this.parseQuotedString();","    return this.parseAtom(terminators);","  }","  ","  parseQuotedString() {","    if (this.peek() !== '\"') throw new Error(`Expected '\"' at position ${this.pos}`);","    this.pos++;","    let result = \"\";","    while (this.pos < this.input.length) {","      const ch = this.input[this.pos];","      if (ch === '\"') { this.pos++; return result; }","      if (ch === \"\\\\\") {","        this.pos++;","        if (this.pos >= this.input.length) throw new Error(\"Unexpected end of input in string escape\");","        const escaped = this.input[this.pos];","        const escapes = { '\"': '\"', \"\\\\\": \"\\\\\", \"/\": \"/\", \"b\": \"\\b\", \"f\": \"\\f\", \"n\": \"\\n\", \"r\": \"\\r\", \"t\": \"\\t\" };","        if (escaped in escapes) result += escapes[escaped];","        else if (escaped === \"u\") {","          const hex = this.input.slice(this.pos + 1, this.pos + 5);","          result += String.fromCharCode(parseInt(hex, 16));","          this.pos += 4;","        } else throw new Error(`Invalid escape sequence '\\\\${escaped}'`);","      } else result += ch;","      this.pos++;","    }","    throw new Error(\"Unterminated string\");","  }","  ","  parseAtom(terminators) {","    const start = this.pos;","    if (terminators === \"\") {","      const token = this.input.slice(start).trim();","      this.pos = this.input.length;","      if (token === \"\") throw new Error(`Unexpected end of input at position ${start}`);","      if (token === \"null\") return null;","      if (token === \"true\") return true;","      if (token === \"false\") return false;","      const num = Number(token);","      if (!isNaN(num)) return num;","      return token;","    }","    while (this.pos < this.input.length) {","      if (terminators.includes(this.input[this.pos])) break;","      this.pos++;","    }","    const token = this.input.slice(start, this.pos).trim();","    if (token === \"\") throw new Error(`Unexpected character at position ${this.pos}: '${this.peek()}'`);","    if (token === \"null\") return null;","    if (token === \"true\") return true;","    if (token === \"false\") return false;","    const num = Number(token);","    if (!isNaN(num) && token !== \"\") return num;","    return token;","  }","  ","  parseArray() {","    if (this.peek() !== \"[\") throw new Error(`Expected '[' at position ${this.pos}`);","    this.pos++;","    const result = [];","    this.skipWhitespace();","    while (this.peek() !== \"]\") {","      if (this.pos >= this.input.length) throw new Error(\"Unterminated array\");","      result.push(this.parseValue(\",]\"));","      this.skipWhitespace();","      if (this.peek() === \",\") { this.pos++; this.skipWhitespace(); }","    }","    this.pos++;","    return result;","  }","  ","  parseTable() {","    if (this.input.slice(this.pos, this.pos + 2) !== \"{{\") throw new Error(`Expected '{{' at position ${this.pos}`);","    this.pos += 2;","    const result = [];","    let currentSchema = [];","    this.skipWhitespace();","    while (this.input.slice(this.pos, this.pos + 2) !== \"}}\") {","      if (this.pos >= this.input.length) throw new Error(\"Unterminated table\");","      this.skipWhitespace();","      if (this.peek() === \":\") {","        this.pos++;","        currentSchema = this.parseSchemaRow();","      } else {","        if (currentSchema.length === 0) throw new Error(`Data row without schema at position ${this.pos}`);","        const values = this.parseDataRow(currentSchema.length);","        const obj = {};","        for (let i = 0; i < currentSchema.length; i++) obj[currentSchema[i]] = values[i];","        result.push(obj);","      }","      this.skipWhitespace();","      if (this.peek() === \";\") { this.pos++; this.skipWhitespace(); }","    }","    this.pos += 2;","    return result;","  }","  ","  parseSchemaRow() {","    const cols = [];","    let col = \"\";","    while (this.pos < this.input.length) {","      const ch = this.input[this.pos];","      if (ch === \"}\" && this.input[this.pos + 1] === \"}\") { if (col.trim()) cols.push(col.trim()); break; }","      if (ch === \";\" || ch === \"\\n\") { if (col.trim()) cols.push(col.trim()); break; }","      if (ch === \",\") { if (col.trim()) cols.push(col.trim()); col = \"\"; this.pos++; continue; }","      col += ch;","      this.pos++;","    }","    return cols;","  }","  ","  parseDataRow(colCount) {","    const values = [];","    for (let i = 0; i < colCount; i++) {","      this.skipWhitespace();","      const terminators = i < colCount - 1 ? \",;}\\n\" : \";}\\n\";","      values.push(this.parseTableValue(terminators));","      this.skipWhitespace();","      if (this.peek() === \",\") this.pos++;","    }","    return values;","  }","  ","  parseTableValue(terminators) {","    this.skipWhitespace();","    const ch = this.peek();","    if (ch === '\"') return this.parseQuotedString();","    if (ch === \"{\") {","      if (this.input[this.pos + 1] === \"{\") return this.parseTable();","      return this.parseObject();","    }","    if (ch === \"[\") return this.parseArray();","    const start = this.pos;","    while (this.pos < this.input.length) {","      const c = this.input[this.pos];","      if (c === \"}\" && this.input[this.pos + 1] === \"}\") break;","      if (terminators.includes(c)) break;","      this.pos++;","    }","    const token = this.input.slice(start, this.pos).trim();","    if (token === \"\" || token === \"null\") return null;","    if (token === \"true\") return true;","    if (token === \"false\") return false;","    const num = Number(token);","    if (!isNaN(num)) return num;","    return token;","  }","  ","  parseObject() {","    if (this.peek() !== \"{\") throw new Error(`Expected '{' at position ${this.pos}`);","    this.pos++;","    const result = {};","    this.skipWhitespace();","    while (this.peek() !== \"}\") {","      if (this.pos >= this.input.length) throw new Error(\"Unterminated object\");","      const { key: keyPath, quoted } = this.parseKey();","      this.skipWhitespace();","      if (this.peek() !== \":\") throw new Error(`Expected ':' after key '${keyPath}' at position ${this.pos}`);","      this.pos++;","      const value = this.parseValue(\",}\");","      if (quoted) result[keyPath] = value;","      else this.mergeObjects(result, this.unfoldKey(keyPath, value));","      this.skipWhitespace();","      if (this.peek() === \",\") { this.pos++; this.skipWhitespace(); }","    }","    this.pos++;","    return result;","  }","  ","  parseKey() {","    this.skipWhitespace();","    if (this.peek() === '\"') return { key: this.parseQuotedString(), quoted: true };","    const start = this.pos;","    while (this.pos < this.input.length) {","      const ch = this.input[this.pos];","      if (/[:\\,{}\\[\\];]/.test(ch) || /\\s/.test(ch)) break;","      this.pos++;","    }","    const key = this.input.slice(start, this.pos);","    if (key === \"\") throw new Error(`Expected key at position ${this.pos}`);","    return { key, quoted: false };","  }","  ","  unfoldKey(keyPath, value) {","    const parts = keyPath.split(\".\");","    let result = {}, current = result;","    for (let i = 0; i < parts.length - 1; i++) {","      const nested = {};","      current[parts[i]] = nested;","      current = nested;","    }","    current[parts[parts.length - 1]] = value;","    return result;","  }","  ","  mergeObjects(target, src) {","    for (const key of Object.keys(src)) {","      if (key in target && typeof target[key] === \"object\" && target[key] !== null && !Array.isArray(target[key]) &&","          typeof src[key] === \"object\" && src[key] !== null && !Array.isArray(src[key])) {","        this.mergeObjects(target[key], src[key]);","      } else target[key] = src[key];","    }","  }","}","","function parse(input) {","  return new JotParser(input).parse();","}","","// Export for browser","window.Jot = { stringify, parse };"]}